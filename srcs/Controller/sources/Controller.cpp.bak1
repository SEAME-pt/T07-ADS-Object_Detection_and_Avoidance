#include "Controller.hpp"
#include <iostream>

Controller::Controller(JetCar* jetCar) : joystick(nullptr), jetCar(jetCar), _currentMode(MODE_JOYSTICK) {
    if (SDL_Init(SDL_INIT_JOYSTICK) < 0) {
        throw std::runtime_error("Failed to initialize SDL2 Joystick: " + std::string(SDL_GetError()));
    }

    int joystickCount = SDL_NumJoysticks();
    std::cout << "NÃºmero de joysticks conectados: " << joystickCount << std::endl;

    buttonStates.fill(false);

    if (joystickCount > 0) {
        joystick = SDL_JoystickOpen(0);
        if (joystick) {
            std::cout << "Joystick 0 conectado!" << std::endl;
        } else {
            throw std::runtime_error("Falha ao abrir o joystick: " + std::string(SDL_GetError()));
        }
    } else {
        throw std::runtime_error("Nenhum joystick detectado.");
    }

    std::string pipeline = "appsrc ! videoconvert ! x264enc tune=zerolatency bitrate=500 speed-preset=superfast ! "
                          "rtph264pay ! udpsink host=192.168.43.190 port=5000 sync=false";
    video_writer.open(pipeline, cv::CAP_GSTREAMER, 0, 30.0, cv::Size(640, 360), true);
    if (!video_writer.isOpened()) {
        throw std::runtime_error("Falha ao abrir o VideoWriter para streaming!");
    }
    std::cout << "Streaming iniciado em udp://0.0.0.0:5000" << std::endl;
}

Controller::~Controller() {
    if (joystick) {
        SDL_JoystickClose(joystick);
    }
    SDL_Quit();
}

void Controller::setButtonAction(int button, Actions actions) {
    buttonActions[button] = actions;
}

void Controller::setAxisAction(int axis, std::function<void(int)> action) {
    axisActions[axis] = action;
}

void Controller::processEvent(const SDL_Event& event) {
    if (event.type == SDL_JOYBUTTONDOWN || event.type == SDL_JOYBUTTONUP) {
        bool isPressed = (event.type == SDL_JOYBUTTONDOWN);
        int button = event.jbutton.button;

        if (button < static_cast<int>(buttonStates.size())) {
            std::cout << "Button " << button << " " << (isPressed ? "pressed" : "released") << std::endl;
            buttonStates[button] = isPressed;
            if (buttonActions.find(button) != buttonActions.end()) {
                if (isPressed && buttonActions[button].onPress) {
                    buttonActions[button].onPress();
                } else if (!isPressed && buttonActions[button].onRelease) {
                    buttonActions[button].onRelease();
                }
            }
        }
    } else if (event.type == SDL_JOYAXISMOTION && _currentMode != MODE_AUTONOMOUS) {
        int axis = event.jaxis.axis;
        int value = event.jaxis.value;
        std::cout << "Axis " << axis << " moved to " << value << std::endl;
        if (axisActions.find(axis) != axisActions.end()) {
            axisActions[axis](value);
        }
    } else if (event.type == SDL_JOYAXISMOTION && _currentMode == MODE_AUTONOMOUS) {
        int axis = event.jaxis.axis;
        int value = event.jaxis.value;
        std::cout << "Axis " << axis << " moved to " << value << std::endl;
        if (axisActions.find(axis) != axisActions.end() && axis == 3) {
            axisActions[axis](value);
        }
    } else if (event.type == SDL_JOYDEVICEADDED) {
        std::cout << "Joystick on!" << std::endl;
        if (!joystick) {
            joystick = SDL_JoystickOpen(0);
            if (joystick) {
                std::cout << "Joystick 0 conectado!" << std::endl;
            } else {
                throw std::runtime_error("Falha ao abrir o joystick: " + std::string(SDL_GetError()));
            }
        }
    } else if (event.type == SDL_JOYDEVICEREMOVED) {
        std::cout << "Joystick off!" << std::endl;
        if (joystick) {
            SDL_JoystickClose(joystick);
            joystick = nullptr;
        }
        exit(1);
    }
}

void Controller::setMode(const int &mode) {
    _currentMode = mode;
}

int Controller::getMode() {
    return _currentMode;
}

void Controller::listen() {
    SDL_Event event;
    while (true) {
        while (SDL_PollEvent(&event)) {
            processEvent(event);
        }

        if (_currentMode == MODE_AUTONOMOUS) {
            std::cout << "Modo autÃ´nomo ativado!" << std::endl;
            autonomous();
        }

        if (buttonStates[BTN_SELECT] && buttonStates[BTN_START]) {
            break;
        }

        if (!joystick) {
            std::cout << "No joystick connected, quitting..." << std::endl;
            break;
        }

        SDL_Delay(10);
    }
}

Controller::State Controller::kinematicModel(const State& state, float delta, float a) {
    State next;
    next.x = state.x + state.v * std::cos(state.theta) * DT;
    next.y = state.y + state.v * std::sin(state.theta) * DT;
    next.theta = state.theta + (state.v / L) * std::tan(delta) * DT;
    next.v = state.v + a * DT;
    return next;
}

void Controller::setupCostFunction(Eigen::MatrixXd& H, Eigen::VectorXd& f, const Eigen::VectorXd& y_ref, const Eigen::VectorXd& theta_ref) {
    H.setZero();
    f.setZero();

    for (int i = 0; i < N; ++i) {
        H(i, i) = Q_y;                // Penalize offset
        H(N + i, N + i) = Q_theta;    // Penalize angle
        H(2 * N + i, 2 * N + i) = R_delta;  // Penalize steering
        H(3 * N + i, 3 * N + i) = R_a;      // Penalize acceleration
        f(i) = -Q_y * y_ref[i];
        f(N + i) = -Q_theta * theta_ref[i];
    }

    for (int i = 1; i < N; ++i) {
        H(2 * N + i, 2 * N + i) += R_d_delta;        // Penalize steering change
        H(2 * N + i - 1, 2 * N + i - 1) += R_d_delta;
    }
}

Eigen::VectorXd Controller::solveMPC(const State& initial_state, const Eigen::VectorXd& y_ref, const Eigen::VectorXd& theta_ref) {
    int n_vars = 4 * N;  // y, theta, delta, a for each timestep
    Eigen::MatrixXd H(n_vars, n_vars);
    Eigen::VectorXd f(n_vars);

    setupCostFunction(H, f, y_ref, theta_ref);

    // Controle proporcional ajustado como placeholder
    Eigen::VectorXd control_sequence(2);
    // Steering: CombinaÃ§Ã£o de offset e Ã¢ngulo com ganhos ajustados
    float steering = (0.05f * y_ref[0]) + (0.5f * theta_ref[0]);  // Offset (m) + Angle (rad)
    control_sequence[0] = steering;

    // Throttle: Reduzir com base no Ã¢ngulo (curvas)
    float base_throttle = 0.5f;  // Velocidade base
    float throttle = base_throttle - 0.1f * fabs(theta_ref[0]);  // Reduzir em curvas
    control_sequence[1] = throttle;

    return control_sequence;
}

void Controller::autonomous() {
    if (!laneDetector || !laneDetector->cap_.read(frame)) {
        std::cerr << "ðŸš¨ Erro: NÃ£o foi possÃ­vel capturar a imagem ou LaneDetector nÃ£o inicializado!" << std::endl;
        return;
    }

    float offset, angle;
    laneDetector->processFrame(frame, offset, angle, output_frame, true);

    std::cout << "Ã‚ngulo: " << angle << " graus" << std::endl;
    std::cout << "Offset: " << offset << " pixels" << std::endl;

    // Convert to MPC inputs (meters and radians)
    float y_ref = offset * 0.001f;  // Convert pixels to meters (ajuste conforme necessÃ¡rio)
    float theta_ref = angle * (CV_PI / 180.0f);  // Convert degrees to radians

    // Reference trajectories (desired state: stay centered and aligned)
    Eigen::VectorXd y_ref_vec = Eigen::VectorXd::Zero(N);
    Eigen::VectorXd theta_ref_vec = Eigen::VectorXd::Zero(N);
    for (int i = 0; i < N; ++i) {
        y_ref_vec[i] = y_ref;
        theta_ref_vec[i] = theta_ref;
    }

    // Solve MPC
    Eigen::VectorXd control = solveMPC(current_state_, y_ref_vec, theta_ref_vec);
    float delta = control[0];  // Steering angle (radians)
    float a = control[1];      // Acceleration (m/sÂ²)

    // Apply constraints (ajustado para o intervalo do JetCar: -90 a +90 graus)
    float steering = std::max(-1.5708f, std::min(1.5708f, delta));  // Â±90 graus em radianos
    float throttle = std::max(0.2f, std::min(0.5f, a));  // Map acceleration to throttle range

    // Update state
    current_state_ = kinematicModel(current_state_, steering, throttle);

    // Apply to JetCar
    jetCar->set_servo_angle(steering * (180/3.1416f));  // Steering em radianos (-1.5708 a +1.5708)
    jetCar->set_motor_speed(throttle * 35.0f);

    std::cout << "Steering: " << steering << " rad, Throttle: " << throttle << std::endl;

    video_writer.write(output_frame);
}

void Controller::setLaneDetector(std::unique_ptr<LaneDetector> detector) {
    laneDetector = std::move(detector);
}
